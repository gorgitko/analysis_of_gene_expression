---
title: "E02 - Intro to advanced R (Analysis of Gene Expression @ VSCHT)"
author: "Jiri Novotny"
institute: "Laboratory of Genomics and Bioinformatics @ Institute of Molecular Genetics of the ASCR"
output:
  html_document:
    # code_folding: "show"
    df_print: "paged"
    toc: true
    toc_float: true
    toc_collapsed: false
    toc_depth: 4
    number_sections: false
    theme: "united"
    self_contained: true
    css: "../stylesheet.css"
---

---
date: '`r glue("Document generated: {Sys.Date()}")`'
---

```{r, include = FALSE, echo = FALSE}
if (!require(emo))
  devtools::install_github("hadley/emo")
```

***

Copy, please, these files and directories to your personal directory:

```{bash, eval = FALSE}
cp -r /data/shared/AGE2020/Exercises/E02-intro_to_advanced_R ~/AGE2020/Exercises
```

And switch the R working directory to the current exercise:

```{r}
setwd("~/AGE2020/Exercises/E02-intro_to_advanced_R")
```

You will probably need to install these packages:

```{r, eval = FALSE}
BiocManager::install(c("ggcorrplot", "hrbrthemes", "see", "janitor", "psych"))
```

***

# Introduction to tidyverse

Until now you have been probably using only the base R.
[Tidyverse](https://www.tidyverse.org/) can be seen as a dialect of R and is described as follows:

> The tidyverse is an opinionated collection of R packages designed for data science.
  All packages share an underlying design philosophy, grammar, and data structures.

Tidyverse is very popular these days, but as some ([here](https://github.com/matloff/TidyverseSkeptic)
and [here](http://r4stats.com/2017/03/23/the-tidyverse-curse/)) have noted,
it is not suitable for R beginners.

**Useful links**

- [List of tidyverse packages](https://www.tidyverse.org/packages/)
- [R for Data Science](https://r4ds.had.co.nz/) - an amazing tutorial book for R which is mainly using tidyverse.
- [**Awesome list of cheatsheets**](https://rstudio.com/resources/cheatsheets/).
  Some of them are also accessible in RStudio: `Help -> Cheatsheets`

## Tidy (long) data

Tidyverse packages are not meant to replace the base R.
Especially, they are not suited for matrix manipulation, and are specifically used for **long data**
(also called **tidy data**). More about tidy data can be found [here](https://r4ds.had.co.nz/tidy-data.html).

Following three rules makes a dataset tidy:

- Each variable must have its own column.
- Each observation must have its own row.
- Each value must have its own cell.

![Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells.](images/tidy_data.png)

As you will see, we will be mostly working with biological matrices (= data in **wide** format).
For example, consider this datafame:

```{r}
(df_wide <- data.frame(sample_1 = 1:2, sample_2 = 3:4, sample_3 = 5:6, row.names = c("gene_A", "gene_B")))
```

For each sample (column) and each gene (row) we have its value (cell).
This form of data is usable for functions operating on matrices (e.g. PCA), but as you will see later, not for e.g. plotting
(besides base R plotting).

This dataframe has wide format, and thus it is not tidy.
You can see that rownames and colnames are, in fact, values of variables `Gene` and `Sample`, respectively.
So how would this dataframe look like in tidy format? Don't be surprised now, we will get to this code later.

```{r}
library(magrittr)

df_long <- df_wide %>%
  tibble::rownames_to_column("Gene") %>%
  tidyr::pivot_longer(-Gene, names_to = "Sample", values_to = "Count")
df_long
```

Now `df_long` is tidy and corresponds to long format of the original dataframe.
We actually did this:

![Converting wide data to long format.](images/wide_to_long.png)

Why is long data useful for some purposes (mainly for plotting)?
Well, for biological matrix like the one in `df`, you usually also have a sample sheet, for example:

```{r}
(sample_sheet <- data.frame(Sample = c("sample_1", "sample_2", "sample_3"), Age = 1:3, Treatment = c("yes", "no", "yes")))
```

Would it be neat to have this information alongside the long data (`df_long`)?
I think so:

```{r}
dplyr::left_join(df_long, sample_sheet, by = "Sample")
```

**As you will see later, this long form of data is extremely useful for plotting.**
In this blog [post](http://varianceexplained.org/r/tidy-genomics/), there is a nice example of using tidy data and tidyverse in genomics.

## Non-standard evaluation (NSE)

Let's go ahead a bit and look at this `select()` function from `dplyr` package (will be introduced later):

```{r}
dplyr::select(mtcars, cyl, mpg) %>% head()
```

You can see that `select()` is filtering columns of the dataframe.
But it has a strange syntax, hasn't it? We have used variables, which are not defined.
Don't be scared by this dark magic - it is based on R's [lazy evaluation](https://colinfay.me/tidyeval-1/)
([details](https://www.r-bloggers.com/about-lazy-evaluation/))
and it's called **[non-standard evaluation](https://tidynomicon.tech/nse.html)** (NSE).
**In short, R only evaluates the expression if the expression is actually used.**

Tidyverse functions use NSE to look first at variables inside a passed object (columns = variables).
Most of these functions are designed to have their first parameter as data object.
When variables are not found inside the object, function will look for variables in the global environment
(this can cause unwanted problems, when object has variable with the same name as the one in global environment).
So in the example above, `cyl` and `mpg` variables are evaluated in the context of `mtcars` object and environment
defined in `select()` function call.

NSE is a quite advanced topic and its knowledge is mainly needed for implementation of custom functions, which share the tidyverse philosophy.
See `vignette("programming")` and [`friendlyeval`](https://github.com/MilesMcBain/friendlyeval),
a friendly interface for NSE programming.

Now we will quickly look at the most popular tidyverse packages.

## [`magrittr`](https://magrittr.tidyverse.org/) - pipe operator

The pipe operator is probably the basic compound of shell programming.
Fortunately for us, it is also implemented in R.

The pipe operator (see <code>?&grave;%>%&grave;</code>) is forwarding output from left hand side (LHS) to input on right hand side (RHS).
The default behaviour is to pipe output to the first argument of a RHS function.

So instead of using nested functions like

```{r}
head(rownames(mtcars))
```

you can use the pipe operator:

```{r}
rownames(mtcars) %>% head()
```

And there are even [more types of pipes](https://magrittr.tidyverse.org/reference/index.html).

Piped object is available on RHS as the `.` object.
It is used when you want:

- To use an argument different than first of the RHS function:

```{r}
c("first", "second", "third") %>% paste("I am", ., sep = " ")
```

- To use the LHS output as a regular R object:

```{r}
mtcars %>% .$cyl
mtcars %>% .[1:5, 1:3]
```

- To use a lambda expression. They behave like a function with single parameter `.`:

```{r}
mtcars %>% {head(.$cyl)}
mtcars %>% {
  my_data <- .
  c(min(my_data), max(my_data))
}
```

Or you can define an anonymous function:

```{r}
mtcars %>% (function(my_data) c(min(my_data), max(my_data)))
```

Using arithmetic and other operators together with pipe can be more pleasant with provided [aliases](https://magrittr.tidyverse.org/reference/aliases.html).

Add and subtract operators are working fine:

```{r}
1 %>% + 2 %>% - 3
```

But for the sake of consistency, rather use operator aliases:

```{r}
1 %>% add(2) %>% subtract(3)
```

However, how would you use, for example, `==` or `*` operator?

```{r, error = TRUE}
1 %>% == 2
1 %>% * 3
```

You have to use aliases:

```{r}
1 %>% equals(2)
1 %>% multiply_by(3)
```

In fact, all aliases are actually shorthands for writing operators as "classic" functions, e.g. <code>&grave;*&grave;(x, y)</code>.
So the examples above can be also written as:

```{r}
1 %>% `==`(2)
1 %>% `*`(3)
```

***

## [`tibble`](https://tibble.tidyverse.org/) - enhanced data.frame

There are some differences to `data.frame` (see link above and examples [here](https://r4ds.had.co.nz/tibbles.html)),
but the most visible difference is in printing of a tibble:

```{r}
tibble::as_tibble(mtcars)
```

`tibble` is showing the data types of variables.
Also you can see that there aren't rownames -
this is strange, but it is one of the features of `tibble`.
Authors of `tibble` package are convinced that rownames should be represented by variable (column) and
not by object's attribute, accessible by `rownames()` method.

**This is bad particularly for usage of tidyverse together with Bioconductor, where
rownames are an essential component.**
Many tidyverse functions return a `tibble` or drop rownames, but most of times we rather want `data.frame`
with defined rownames.
`tibble` can be converted to `data.frame` by `as.data.frame()` function.

**To preserve rownames in a new column, use the `tibble::rownames_to_column("name_of_new_column")` function.**

Useful is the `tribble()` function for more readable creation of (small) tables in code:

```{r}
tibble::tribble(
  ~column_A, ~column_B,
  "a",   1,
  "b",   2,
  "c",   3
)
```

## [`dplyr`](https://dplyr.tidyverse.org/) - data manipulation

`dplyr` is probably the most popular package from tidyverse.
It helps to solve the most common data manipulation challenges and
its sibling [`dbplyr`](https://dbplyr.tidyverse.org/articles/dbplyr.html)
also supports remote data stored in a database (MySQL, PostreSQL, SQLite, and others).

Some functions in `dplyr` have names similar to functions from other packages.
**Thus, it is recommended to always specify the `dplyr::` namespace.**

- [Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf)

### [`select()`](https://dplyr.tidyverse.org/reference/select.html) - select (filter) columns

```{r}
library(dplyr)
mtcars_sm <- head(mtcars)
dplyr::select(mtcars_sm, cyl, mpg)
```

By using `-` you can also specifify columns to **omit**:

```{r}
dplyr::select(mtcars_sm, -cyl, -mpg)
```

We can select a range of variables.
Numerical range is also supported, e.g. `1:5`.
Omitting a range is also possible - in this example you would use `-(disp:drat)`.

```{r}
dplyr::select(mtcars_sm, disp:drat)
```

There are also very useful [select helpers](https://www.rdocumentation.org/packages/tidyselect/topics/select_helpers).
For omitting they can be also combined with `-`.

Select columns starting with "c":

```{r}
dplyr::select(mtcars_sm, starts_with("c"))
```

Select columns containing "ar":

```{r}
dplyr::select(mtcars_sm, contains("ar"))
```

Select column at `last - 1` position:

```{r}
dplyr::select(mtcars_sm, last_col(1))
```

Select columns having names in vector and don't throw error on non-existing column:

```{r, warning = TRUE}
dplyr::select(mtcars_sm, one_of(c("mpg", "cyl", "garbage")))
```

Because this will fail:

```{r, error = TRUE}
dplyr::select(mtcars_sm, mpg, cyl, garbage)
```

`select()` can also select and rename columns at the same time:

```{r}
dplyr::select(mtcars_sm, cylinders = cyl, horse_power = hp)
```

To only rename specific and keep other columns, use `rename()` function:

```{r}
dplyr::rename(mtcars_sm, cylinders = cyl, horse_power = hp)
```

Using the `everything()` select helper also works, but you will lose the original column order:

```{r}
dplyr::select(mtcars_sm, cylinders = cyl, horse_power = hp, everything())
```

`select()` always returns an object of the same type as input.
However, sometimes you rather need a vector: `pull()` returns a vector of specified variable.

```{r}
dplyr::pull(mtcars_sm, cyl)
```

### [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html) - order rows

`arrange()` orders rows by specified variables.

```{r}
dplyr::arrange(mtcars_sm, cyl, disp)
```

Use `desc()` or `-` for descending order:

```{r}
dplyr::arrange(mtcars_sm, desc(cyl))
# or
# dplyr::arrange(mtcars_sm, -cyl)
```

### [`filter()`](https://dplyr.tidyverse.org/reference/filter.html) - filter rows

In fact, `filter()` is very similar to base R function `subset()`, but offers much more functionality.

Multiple arguments are equivalent to AND operator:

```{r}
dplyr::filter(mtcars_sm, hp > 100, cyl == 6)
```

So this is equivalent:

```{r}
dplyr::filter(mtcars_sm, hp > 100 & cyl == 6)
```

Thanks to NSE we can do some magic.
Here, we want rows where `hp` is greater than mean value of `hp` minus `10`:

```{r}
dplyr::filter(mtcars_sm, hp > mean(hp) - 10)
```

### [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html) - add new or modify existing variables

Named parameters of `mutate()` function create new variables (or modify existing, if a parameter name is same).

```{r}
tibble::rownames_to_column(mtcars_sm, "car_name") %>%
  dplyr::mutate(cyl2 = cyl * 2) %>%
  dplyr::select(car_name, cyl, cyl2)
```

`mutate()` is one of the tidyverse functions, which silently drop rownames.
To preserve them, we have moved rownames to the new column `car_name`.

This is how we remove the column and modify the existing one:

```{r}
dplyr::mutate(mtcars_sm, mpg = NULL, cyl = cyl * 2)
```

Very useful are these "if" functions:

[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.html) checks for a condition and returns values for `TRUE` and `FALSE` matches.
In `missing` parameter you can also specify a return value for `NA` values.
`if_else()` is similar to base R `ifelse()`, but checks for the same return types.

```{r}
dplyr::mutate(mtcars_sm, car_category = if_else(hp >= 100, "strong", "weak")) %>%
  dplyr::select(hp, car_category)
```

You can see that return values must be the same type:

```{r, error = TRUE}
dplyr::mutate(mtcars_sm, car_category = if_else(hp >= 100, "strong", 50)) %>%
  dplyr::select(hp, car_category)
```

[`recode()`](https://dplyr.tidyverse.org/reference/recode.html) replaces values, similar to `switch()`.
You can specify default return value for not-specified and `NA` values (`.default` and `.missing` parameters).
Very useful for replacing factor values while preserving their order.

```{r}
dplyr::mutate(mtcars_sm, am_char = recode(am, `0` = "zero", `1` = "one")) %>%
  dplyr::select(am, am_char)
```

[`recode_factor()`](https://dplyr.tidyverse.org/reference/recode.html) create factors with levels ordered as they appear in the recode call.

```{r}
factor(mtcars_sm$am) %>%
  levels()

# You can notice that mutate() parameters are "executed" from first to last.
# So to "am_char" is already passed "am" as factor, as "am" is mutated before "am_char".
dplyr::mutate(
  mtcars_sm,
  am = factor(am),
  am_char = recode_factor(am, `1` = "one", `0` = "zero")
) %>%
  dplyr::pull(am_char) %>%
  levels()
```

[`case_when()`](https://dplyr.tidyverse.org/reference/case_when.html) allows to specify multiple `if` statements.
Statements are given in a format `condition ~ return_value` and they are matched from first to last.

For `else` statement put `TRUE ~ some_value` as the last statement (if not specified, `some_value` will be `NA`).
As `case_when()` is checking for return types, you have to use appropriate `NA` type:
`NA_integer_`, `NA_real_`, `NA_complex_` or `NA_character_`.
Be careful since `1` is a real number (`numeric` type), whereas `1L` is a true integer.

```{r}
dplyr::mutate(
  mtcars,
  car_category = case_when(
    hp < 80 ~ "weak",
    hp >= 80 & hp <= 100 ~ "middle",
    hp > 100 ~ "strong"
  )
) %>%
  dplyr::select(hp, car_category)
```

All these "if" functions are vectorised and can be also used for vectors:

```{r}
v <- c(1, 1, 2, 3, 10)
if_else(v < 2, "< 2", ">= 2")
```

### [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.html) and [`summarise()`](https://dplyr.tidyverse.org/reference/summarise.html)

`group_by()` is similar to SQL operation of the same name.
It takes an existing dataframe and converts it into a grouped dataframe where operations are performed "by group".

```{r}
(by_cyl <- dplyr::group_by(mtcars, cyl))
```

Better is to see the original `tibble` in your console, where is information about groups.

Now we can perform operations on groups.
`summarise()` reduces multiple values down to a single value.
Let's calculate some statistics in the `cyl` groups:

```{r}
dplyr::summarise(
  by_cyl,
  mpg_mean = mean(mpg),
  hp_max = max(hp),
  qsec_median = median(qsec),
  wt_sd = sd(wt)
)
```

[`n()`](https://dplyr.tidyverse.org/reference/n.html) is a special function to get counts inside groups:

```{r}
dplyr::summarise(
  by_cyl,
  n = n()
)
```

`filter()` is now acting on groups. Let's compare these two filter operations:

```{r}
dplyr::filter(mtcars, mpg > mean(mpg))
dplyr::filter(by_cyl, mpg > mean(mpg))
```

The former keeps rows with `mpg` greater than the global average whereas the latter keeps rows with `mpg` greater than the average inside the `cyl` groups.

To remove grouping, use the `ungroup()` function.

### [`*_join()`](https://dplyr.tidyverse.org/reference/join.html) and [`bind_rows()`](https://dplyr.tidyverse.org/reference/bind.html) - joining dataframes

A collection of `*_join()` functions acts in the same way as in SQL -
based on common keys, they join two dataframes together.

```{r}
mtcars_prices <- tibble::tribble(
  ~cyl, ~price,
  4,    1000,
  6,    5000,
  8,    10000
)

dplyr::left_join(mtcars_sm, mtcars_prices, by = "cyl") %>%
  dplyr::select(cyl, price)
```

`bind_rows()` append rows to dataframe.
It puts `NA`s to columns not present in both dataframes.

```{r}
dplyr::bind_rows(mtcars_sm, mtcars_prices) %>%
  dplyr::select(cyl, price, everything())
```

***

## [`tidyr`](https://tidyr.tidyverse.org/) - tools for tidy data

The goal of `tidyr` is to help you to create [tidy data](https://tidyr.tidyverse.org/articles/tidy-data.html).
Just to remind you, tidy data is data where:

- Every column is variable.
- Every row is an observation.
- Every cell is a single value.

[Cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-import.pdf) on reading and tidying data.

Let's look at some of basic tasks `tidyr` can do:

### Pivotting

[Pivotting](https://tidyr.tidyverse.org/articles/pivot.html) converts between long and wide forms.
We will reuse the wide `df_wide` dataframe.

[`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.html) "lengthens" data,
increasing the number of rows and decreasing the number of columns.

```{r}
df_wide

df_long <- df_wide %>%
  tibble::rownames_to_column("Gene") %>%
  tidyr::pivot_longer(-Gene, names_to = "Sample", values_to = "Count")
df_long
```

We have added rownames of `df_wide` to the new column `Gene`.
In `pivot_longer()` we specified by `-Gene` we want to lengthen this column.

Of course more than one column can be lengthened.
Let's add more columns to `df_wide`:

```{r}
df_wide2 <- df_wide %>%
  tibble::rownames_to_column("Gene_symbol") %>%
  dplyr::mutate(
    Gene_ID = c("ENSG0001", "ENSG0002"),
    Gene_class = c("protein_coding", "miRNA")
  )

df_wide2

df_long2 <- df_wide2 %>%
  tidyr::pivot_longer(-c(Gene_symbol, Gene_ID, Gene_class), names_to = "Sample", values_to = "Count")

df_long2
```

We can see gene columns have the same prefix, and so we can utilize that:
[select helpers](https://www.rdocumentation.org/packages/tidyselect/topics/select_helpers) are allowed here.

```{r}
df_wide2 %>%
  tidyr::pivot_longer(-starts_with("Gene_"), names_to = "Sample", values_to = "Count")
```

[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.html) "widens" data, increasing the number of columns and decreasing the number of rows.

```{r}
tidyr::pivot_wider(df_long, names_from = "Sample", values_from = "Count")
tidyr::pivot_wider(df_long2, names_from = "Sample", values_from = "Count")
```

### Splitting and combining character columns

[`separate()`](https://tidyr.tidyverse.org/reference/separate.html) turns a single character column into multiple columns.

```{r}
(df <- data.frame(x = c(NA, "a.b", "a.d", "b.c")))
tidyr::separate(df, x, c("A", "B"), sep = "\\.")
```

[`extract()`](https://tidyr.tidyverse.org/reference/separate.html) turns each capturing group into a new column.

```{r}
(df <- data.frame(x = c(NA, "a-1-x", "a-2-y", "a-3")))
tidyr::extract(df, x, c("A", "B", "C"), regex = "([a-z])-(\\d)-?([a-z])?")
```

[`unite()`](https://tidyr.tidyverse.org/reference/unite.html) pastes together multiple columns into one.

```{r}
(df <- data.frame(x = c(NA, "a", "b", "c"), y = c("a", "f", "g", "h")))
tidyr::unite(df, "x_y", x, y, sep = "_", remove = FALSE)
```

### Other `tidyr` functions

[`drop_na()`](https://tidyr.tidyverse.org/reference/drop_na.html) drops rows containing missing values.

```{r}
(df <- data.frame(x = c(1, NA, 2), y = c(1, 2, NA)))
tidyr::drop_na(df)
tidyr::drop_na(df, x)
```

[`replace_na()`](https://tidyr.tidyverse.org/reference/replace_na.html) replaces missing values.

For dataframes, specify a list of columns and replacements.

```{r}
tidyr::replace_na(df, list(x = 5, y = 10))
```

For vectors, specify a replacement value.

```{r}
tidyr::replace_na(c(1, NA, 3), 2)
```

## [`stringr`](https://stringr.tidyverse.org/) - consistent wrappers for common string operations

`stringr` is a replacement for base R collection of string manipulation functions (e.g. `grep()`, `gsub()`, etc., see `?grep`).
In my opinion, `stringr` API is more user-friendly.
All its functions start with `str_` prefix and are vectorised over input string and pattern.

**Useful links**

- [Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/strings.pdf)
- [RegExplain](https://www.garrickadenbuie.com/project/regexplain/) -
  RStudio addin providing a friendly interface for working with regular expressions and functions from stringr.
- [Regex101](https://regex101.com/) - cool web application for regex testing.

Because [`stringr` homepage](https://stringr.tidyverse.org/) offers a nice collection of examples,
I will just copy-paste them here and possibly add more information.

```{r}
library(stringr)

x <- c("why", "video", "cross", "extra", "deal", "authority")
str_length(x)
```

[`str_c(..., sep = "", collapse = NULL)`](https://stringr.tidyverse.org/reference/str_c.html) concatenates a vector of strings.

```{r}
str_c(x, collapse = ", ")
```

[`str_sub(string, start = 1L, end = -1L)`](https://stringr.tidyverse.org/reference/str_sub.html) extracts a substring by a position.
Positions can be also negative.

```{r}
str_sub(x, 1, 2)
str_sub(x, -2)
```

[`str_detect(string, pattern, negate = FALSE)`](https://stringr.tidyverse.org/reference/str_detect.html) tells you if thereâ€™s any match to the pattern.
Handy in `dplyr::filter()`.

```{r}
str_detect(x, "[aeiou]")
str_detect(x, "[aeiou]", negate = TRUE)
```

[`str_count(x, pattern)`](https://stringr.tidyverse.org/reference/str_count.html) counts the number of patterns.

```{r}
str_count(x, "[aeiou]")
```

[`str_subset(string, pattern, negate = FALSE)`](https://stringr.tidyverse.org/reference/str_subset.html) extracts the matching components.
[`str_which(string, pattern, negate = FALSE)`](https://stringr.tidyverse.org/reference/str_subset.html) gives indices of the matching components.

```{r}
str_subset(x, "[aeiou]")
str_subset(x, "[aeiou]", negate = TRUE)
str_which(x, "[aeiou]")
```

[`str_locate(string, pattern)`](https://stringr.tidyverse.org/reference/str_locate.html) gives the position of the match.

```{r}
str_locate(x, "[aeiou]")
```

[`str_extract(string, pattern)`](https://stringr.tidyverse.org/reference/str_extract.html) extracts the text of the match.
Return value = vector.

```{r}
x
str_extract(x, "[aeiou]")
```

[`str_match(string, pattern)`](https://stringr.tidyverse.org/reference/str_match.html) extracts parts of the match defined by parentheses
(capturing groups).
Return value = matrix, with rows being input vector values, and columns being capturing groups.
First column represents the full match.

```{r}
x
str_match(x, "(.)[aeiou](.)")
```

[`str_replace(string, pattern, replacement)`](https://stringr.tidyverse.org/reference/str_replace.html) replaces the matches with new text.
`replacement` also supports references of the form `\1`, `\2`, etc., which will be replaced with the contents of the respective matched group (created by `()`).
[`str_remove(string, pattern)`](https://stringr.tidyverse.org/reference/str_remove.html) is an alias for `str_replace(string, pattern, "")`.

```{r}
str_replace(x, "[aeiou]", "?")
str_replace_all(x, "[aeiou]", "?")
str_replace(x, "(a)", "\\1_")
str_remove(x, "[aeiou]")
str_remove_all(x, "[aeiou]")
```

[`str_split(string, pattern, n = Inf, simplify = FALSE)`](https://stringr.tidyverse.org/reference/str_split.html) splits up a string into multiple pieces.

```{r}
str_split(c("a,b", "c,d,e"), ",")
```

## [`glue`](https://glue.tidyverse.org/) - string interpolation

`glue` offers the same functionality, which you already know from e.g. Bash (`"$variable"`) or Python (`f"{variable}"`).

```{r}
library(glue)
name <- "Fred"
age <- 50
anniversary <- as.Date("1991-10-12")
glue("My name is {name}, my age next year is {age + 1}, my anniversary is {format(anniversary, '%A, %B %d, %Y')}.")
```

Equivalently, we can break long string to multiple parameters on separate lines and use named arguments to assign temporary variables:

```{r, eval = FALSE}
glue(
  "My name is {name},",
  " my age next year is {age + 1},",
  " my anniversary is {format(anniversary, '%A, %B %d, %Y')}.",
  name = "Joe",
  age = 40,
  anniversary = as.Date("2001-10-12")
)
```

# [`ggplot2`](https://ggplot2.tidyverse.org/) - plotting made easy

`ggplot2` is a system for declaratively creating graphics, based on
[The Grammar of Graphics](https://byrneslab.net/classes/biol607/readings/wickham_layered-grammar.pdf).
You provide the data, tell ggplot2 how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details.

![](images/ggplot2_scheme.png){width=50%}

![To create a plot, you start with initialization of a basic `ggplot2` object holding data, and then you add a
[geom](https://ggplot2.tidyverse.org/reference/index.html#section-layer-geoms),
which tells how to visualize the data and how to map variables to aesthetics (color, size, etc.).
This will provide you sensible defaults. To further modify the plot, you can add more components with `+` operator.](images/ggplot2_basic.png){width=50%}

**Useful links**

- [Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-visualization-2.1.pdf)
- [Tutorial](http://r-statistics.co/ggplot2-Tutorial-With-R.html)
- [Quick reference](http://sape.inf.usi.ch/quick-reference/ggplot2) -
  also [colors](http://sape.inf.usi.ch/quick-reference/ggplot2/colour),
  [point shapes](http://sape.inf.usi.ch/quick-reference/ggplot2/shape),
  [line types](http://sape.inf.usi.ch/quick-reference/ggplot2/linetype), etc.
- [Aesthetic specifications](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html) - types of shapes, lines, etc.
- [`ggplot2` essentials](http://www.sthda.com/english/wiki/ggplot2-essentials) - there is probably answer to any "How to...?" question.
- [Top 50 `ggplot2` visualizations](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html)

`ggplot2` is a very extensive library, and so you should mainly know its basic principles and search for details in
the [reference](https://ggplot2.tidyverse.org/reference/index.html).
We will just look at these basic principles.

```{r}
library(ggplot2)
mtcars_sm
ggplot(mtcars) +
  geom_point(aes(x = cyl, y = mpg))
```

We have initialized the `ggplot2` object with `mtcars` data and added `geom_point()`,
which represents a visualization of points in coordinate system.
In this geom, we mapped `x` to `cyl` and `y` to `mpg` variable, respectively.

Each `geom_*()` has available aesthetics to which you can map variables.
Let's add some colors to the previous plot:

```{r}
ggplot(mtcars) +
  geom_point(aes(x = cyl, y = mpg, color = gear))
```

Hmmm but why is `gear` considered as a continuous variable?

```{r}
head(mtcars$gear)
class(mtcars$gear)
```

Because it is defined so.

`ggplot2` has very sensible defaults, so, for example, in case of colors it uses continuous or discrete scale,
based on variable type.
Let's see what happens when we change `gear` type to factor:

```{r}
mtcars2 <- dplyr::mutate(mtcars, gear = factor(gear))
head(mtcars2$gear)

ggplot(mtcars2) +
  geom_point(aes(x = cyl, y = mpg, color = gear))
```

Now you can see that `ggplot2` has created the discrete scale, where each level of `gear` variable has its own color.

Because `ggplot2` is a part of `tidyverse`, it also uses the non-standard evaluation, and so this is equivalent
to the example above, but without modifying the `mtcars` object:

```{r, eval = FALSE}
ggplot(mtcars) +
  geom_point(aes(x = cyl, y = mpg, color = factor(gear)))
```

Aesthetics are inherited and overwritten by last definition.
In this way you haven't to repeat common aesthetics for each geom.
This is equivalent to the example above:

```{r, eval = FALSE}
ggplot(mtcars, aes(x = cyl, y = mpg, color = factor(gear))) +
  geom_point()
```

Let's introduce more `ggplot2` components:

- We map `hp` variable to point size in `geom_point()`.
- We add one more geom, `geom_text()`, which is similar to `geom_point()`, but shows text instead of points.
- `scale_color_manual()` translates discrete values (factor levels) to colors.
  In general, scales control the details of how data values are translated to visual properties.
- `labs()` adds labels to aesthetics and main plot areas (e.g. title).
- `theme_bw()` is a predefined theme with black and white colors.
- `theme()` customizes the non-data components of your plots.
  We can override settings in predefined `theme_*()` themes.

```{r}
p <- ggplot(mtcars, aes(x = qsec, y = mpg)) +
  geom_point(aes(color = factor(gear), size = hp)) +
  geom_text(aes(label = rownames(mtcars)), color = "black") +
  scale_color_manual(values = c("3" = "orchid4", "4" = "darkcyan", "5" = "darkorange1")) +
  labs(
    title = "mtcars", subtitle = "Acceleration vs. Fuel consumption",
    x = "1/4 mile time", y = "Miles per gallon", size = "Horse Power", color = "Gear"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(color = "chocolate4", face = "bold"),
    plot.subtitle = element_text(color = "orangered3"),
    axis.title = element_text(face = "bold")
  )

print(p)
```

Another useful ability of `ggplot2` is facetting.
[`facet_wrap()`](https://ggplot2.tidyverse.org/reference/facet_wrap.html) splits a plot to panels according to discrete variable, which
is specified by formula.
We split the plot by `am` variable (transmission: 0 = automatic, 1 = manual) and
define a translation of labels for its levels.

```{r}
mtcars$am
p + facet_wrap(~ am, labeller = labeller(am = c("0" = "Automatic", "1" = "Manual")))
```

We can specify multiple variables and plot is then created for every combination of their levels.

```{r}
p + facet_wrap(~ am + cyl, labeller = labeller(am = c("0" = "Automatic", "1" = "Manual")))
```

Similar function is [`facet_grid()`](https://ggplot2.tidyverse.org/reference/facet_grid.html) which creates
a matrix of plots.
Rows and columns are specified by LHS and RHS of formula.

```{r}
p + facet_grid(am ~ cyl, labeller = labeller(am = c("0" = "Automatic", "1" = "Manual")))
```

Again, multiple variables are supported, for both LHS and RHS.

```{r}
p + facet_grid(am + vs ~ cyl, labeller = labeller(am = c("0" = "Automatic", "1" = "Manual")))
```

Saving is done via `ggsave()` function.
You can use any format R can handle.

```{r}
ggsave("ggplot2_example.png", p)
ggsave("ggplot2_example.pdf", p)
```

[ggplot2_example.png](ggplot2_example.png)

[ggplot2_example.pdf](ggplot2_example.pdf)

Alternatively, you can use base R functions.
This is useful for saving multiple plots to a single multipage PDF.

```{r, eval = FALSE}
pdf("ggplot2_example.pdf")
print(p)
dev.off()
```

## Using dynamic variable names in aesthetics

You probably wondered, how can you use dynamic variable names in `aes()`.
For example, consider a function `plot_pca(data, color_by)`
which calculates PCA and shows scatterplot colorized by a specified variable.
Although it is possible via NSE (see `vignette("programming")`),
the easiest way is to use `aes_string()` function.

```{r}
color_by <- "cyl"

ggplot(mtcars) +
  geom_point(aes_string(x = "mpg", y = "qsec", color = color_by))
```

The disadvantage is that you cannot use the capabilities of NSE.
In the example above, you cannot specify `factor(color_by)` to treat
`cyl` as factor variable.

## Libraries extending the `ggplot2`

### [`ggpubr`](https://rpkgs.datanovia.com/ggpubr/) - publication-ready plots

```{r}
ggpubr::ggboxplot(
  mtcars, x = "cyl", y = "qsec",
  color = "cyl", shape = "cyl",
  add = "jitter"
)
```

### [`GGally`](https://ggobi.github.io/ggally/index.html) - useful geoms

```{r}
GGally::ggpairs(mtcars, columns = c("cyl", "mpg", "qsec"))
```

### [`cowplot`](https://wilkelab.org/cowplot/articles/aligning_plots.html) - aligning multiple plots

`cowplot` can do more than aligning plots. For example, it can [draw images](https://wilkelab.org/cowplot/reference/draw_image.html).

```{r}
p1 <- ggplot(mtcars) + 
  geom_point(aes(x = disp, y = mpg))
p2 <- ggplot(mtcars) + 
  geom_point(aes(x = disp, y = hp))

cowplot::plot_grid(p1, p2, align = "h")
```

### [`ggforce`](https://ggforce.data-imaginist.com/index.html) - cool functions

```{r}
ggplot(mtcars) +
  geom_point(aes(x = hp, y = qsec, color = factor(gear))) +
  ggforce::facet_zoom(x = gear == 4) +
  theme_bw()
```

### [`ggcorrplot`](https://rpkgs.datanovia.com/ggcorrplot/index.html) - visualize a correlation matrix

```{r}
corr <- round(cor(mtcars), 1)
corr[1:5, 1:5]
p_mat <- ggcorrplot::cor_pmat(mtcars)
p_mat[1:5, 1:5]
p_corr <- ggcorrplot::ggcorrplot(corr, method = "circle", p.mat = p_mat)
print(p_corr)
```

### [`ggrepel`](https://ggrepel.slowkow.com/) - repel overlapping text labels

```{r}
ggplot(mtcars2, aes(x = qsec, y = mpg)) +
  geom_point(aes(color = factor(gear), size = hp)) +
  ggrepel::geom_text_repel(aes(label = rownames(mtcars)), color = "black")
```

## Additional themes

### [`ggsci`](https://nanx.me/ggsci/index.html) - a collection of color palettes inspired by (mainly) scientific journals

Nature Publishing Group color palette:

```{r}
p1 <- ggplot(mtcars) +
  geom_point(aes(x = hp, y = qsec, color = factor(cyl))) +
  theme_bw() +
  ggsci::scale_color_npg()

p2 <- ggplot(mtcars) +
  geom_histogram(aes(x = qsec, fill = factor(cyl)), colour = "black", binwidth = 1, position = "dodge") +
  theme_bw() +
  ggsci::scale_fill_npg()

cowplot::plot_grid(p1, p2, align = "h")
```

### [`hrbrthemes`](https://hrbrmstr.github.io/hrbrthemes/index.html) - themes and color palettes

```{r}
ggplot(mtcars) +
  geom_point(aes(x = hp, y = qsec, color = factor(cyl))) +
  hrbrthemes::theme_modern_rc()
```

### [`see`](https://easystats.github.io/see/index.html) - themes and color palettes

```{r}
ggplot(mtcars) +
  geom_point(aes(x = hp, y = qsec, color = factor(cyl))) +
  see::theme_abyss()
```

### [`cowplot`](https://wilkelab.org/cowplot/articles/themes.html#choosing-themes-in-the-context-of-the-plot)

Not really a collection of e.g. colors, but useful visual helpers with explanation.

# Other useful libraries

## [`janitor`](http://sfirke.github.io/janitor/) - table summaries (RIP `table()`)

Personally, I am mainly using these functions:

[`tabyl()`](http://sfirke.github.io/janitor/reference/tabyl.html) ([vignette](http://sfirke.github.io/janitor/articles/tabyls.html)) creates a frequency table.
It's a replacement for base R `table()`, which has a weird return value with horrible API.

```{r}
janitor::tabyl(mtcars, cyl)
janitor::tabyl(mtcars, cyl, gear)
janitor::tabyl(mtcars, cyl, gear, am)
```

[`adorn_*()`](http://sfirke.github.io/janitor/reference/index.html) append row and/or column with summary statistics.

```{r}
janitor::tabyl(mtcars, cyl, gear) %>%
  janitor::adorn_totals(c("row", "col")) %>%
  janitor::adorn_percentages("row") %>%
  janitor::adorn_pct_formatting(rounding = "half up", digits = 0) %>%
  janitor::adorn_ns() %>%
  as.data.frame()
```

[`get_dupes()`](http://sfirke.github.io/janitor/reference/get_dupes.html) returns duplicated rows.

```{r}
janitor::get_dupes(mtcars, mpg, hp)
```

## [`plotly`](https://plot.ly/r/) - interactive HTML plots

`plotly` is a JavaScript library with wrappers for R and Python.
It is somewhat similar to `ggplot2` in terms of The Grammar of Graphics.
Output is a HTML file or in case of RMarkdown, it can be directly embedded as chunk output.

We want go into details, so if you are interested, see [examples](https://plot.ly/r/#fundamentals).
We will try to replicate the `mtcars` scatterplot done in `ggplot2`:

```{r}
p_ggplot2 <- ggplot(mtcars2, aes(x = qsec, y = mpg)) +
  geom_point(aes(color = factor(gear), size = hp)) +
  theme_bw()

print(p_ggplot2)
```

```{r}
p_plotly <- plotly::plot_ly(
  data = mtcars,
  x = ~qsec, y = ~mpg, color = ~factor(gear), size = ~hp,
  type = "scatter", mode = "markers",
  text = ~glue("mpg: {mpg}<br>qsec: {qsec}<br>gear: {gear}<br>hp: {hp}")
)

p_plotly
```

`plotly` can also convert `ggplot2` objects, but it's not always accurate.

```{r}
plotly::ggplotly(p_ggplot2)
```

But this seems to be quite good, even better than `p_plotly`.

`plotly` produces objects inheriting from `htmlwidget` class.
We can use `htmlwidgets` package to save `plotly` object to HTML file.

```{r}
class(p_plotly)
htmlwidgets::saveWidget(p_plotly, "p_plotly.html")
```

[p_plotly.html](p_plotly.html)

## [`heatmaply`](http://talgalili.github.io/heatmaply/) - interactive HTML heatmaps

`heatmaply` uses `plotly` as a backend.
Its API is mostly compatible with the classic [`heatmap.2()`](https://www.rdocumentation.org/packages/gplots/versions/3.0.1.2/topics/heatmap.2) function.

```{r}
heatmaply::heatmaply(mtcars)
```

It has also functionality similar to `ggcorrplot`:

```{r}
cor <- psych::corr.test(mtcars)

heatmaply::heatmaply_cor(
  cor$r,
  node_type = "scatter",
  point_size_mat = -log10(cor$p), 
  point_size_name = "-log10(p-value)",
  label_names = c("x", "y", "Correlation")
)
```

## [`pheatmap`](https://rdrr.io/cran/pheatmap/) - pretty heatmaps in base R

The ordinary `heatmap()` function in R has several drawbacks when it comes to producing publication quality heatmaps.
It is hard to produce pictures with consistent text, cell and overall sizes and shapes.
The function `pheatmap()` tries to alleviate the problems by offering more fine grained control over heatmap dimensions and appearance.

You can find a bioinformatic use case [here](https://davetang.org/muse/2018/05/15/making-a-heatmap-in-r-with-the-pheatmap-package/).

```{r}
annotation_col <- mtcars[, c("cyl", "gear")]
head(annotation_col)

hclust_cols <- hclust(dist(t(mtcars)), method = "complete") %>%
  dendextend::cutree(tree = as.dendrogram(.), k = 2)
annotation_row <- data.frame(
  Cluster = if_else(hclust_cols == 1, "Cluster 1", "Cluster 2"),
  row.names = colnames(mtcars)
)
head(annotation_row)

pheatmap::pheatmap(t(mtcars), annotation_col = annotation_col, annotation_row = annotation_row)
```

# Parallelization

[`BiocParallel`](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html)
package provides easy-to-use functions for parallel execution.
We won't go into details and just introduce probably the most used function `bplapply()`,
a parallelized version of `lapply()`.

As you know, `lapply(X, FUN, ...)` applies `FUN` with optional arguments `...` to each element
of `X`:

```{r}
x <- 1:5
fn <- function(i) i^2
lapply(x, fn)
```

`bplapply(X, FUN, ..., BPREDO = list(), BPPARAM = bpparam())` does the same, but each element is processed in parallel.
Result is guaranteed to have the same order of elements as in `X`.

```{r}
BiocParallel::bplapply(x, fn)
```

Defaultly, all available cores are used.
To control for resources, use the `BPPARAM` argument.

```{r}
(bpparam <- BiocParallel::MulticoreParam(workers = 2))
```

```{r, eval = FALSE}
BiocParallel::bplapply(x, fn, BPPARAM = bpparam)
```

Parallel processing is hard to debug, even with try-catch equivalent function `bptry()`.
Also, you can't use `browser()` inside `FUN`.
But sometimes is just enough to run `bplapply()` in non-parallel (serial) mode.
This is possible with `SerialParam()`.

```{r, eval = FALSE}
(bpparam <- BiocParallel::SerialParam())
fn <- function(i) {
  browser()
  i^2
}

BiocParallel::bplapply(x, fn, BPPARAM = bpparam)
```

`BiocParallel` supports jobs in distributed systems and much more,
but for now we can live only with the simple multicore usage.

# Cleanup

```{r, warning = TRUE, message = TRUE}
save.image("intro_to_advanced_R.RData")

warnings()
traceback()
sessionInfo()
```

# HTML rendering

This chunk is not evaluated (`eval = FALSE`). Otherwise you will probably end up in recursive hell `r emo::ji("exploding_head")`

```{r, eval = FALSE, message = FALSE, warning = FALSE}
library(rmarkdown)
library(knitr)
library(glue)

# You can set global chunk options. Options set in individual chunks will override this.
opts_chunk$set(warning = FALSE, message = FALSE)
render("intro_to_advanced_R.Rmd", output_file = "intro_to_advanced_R.html")
```
