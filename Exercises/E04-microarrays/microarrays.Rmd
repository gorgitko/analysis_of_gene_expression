---
title: "E04 - Affymetrix microarrays (Analysis of Gene Expression @ UCT Prague)"
author:
  - Jiri Novotny jiri.novotny@img.cas.cz
  - Studuj bioinformatiku! http://studuj.bioinformatiku.cz
institute: "Laboratory of Genomics and Bioinformatics @ Institute of Molecular Genetics of the ASCR"
output:
  rmdformats::readthedown:
    highlight: "kate"
    lightbox: true
    thumbnails: true
    gallery: true
    toc_depth: 4
    self_contained: true
    number_sections: false
    toc_collapsed: false
    df_print: "paged"
date: "`r Sys.Date()`"
---

```{r, child = here::here("_assets/custom.Rmd"), eval = TRUE}
```

```{css, echo = FALSE}
.assay {
  color: #FF7E7E;
}

.pData {
  color: #BF7EBF;
}

.fData {
  color: #7E7EFF;
}
```

***

Copy, please, these files and directories to your personal directory:

```{bash, eval = FALSE}
cp -r ~/shared/AGE_current/Exercises/E04-microarrays ~/AGE/Exercises
```

# Assignment

## Task 1

Implement the `select_var_features(m, n_top_features)` function in `age_library.R`.
This function will subset matrix `m`s rows by `n_top_features` with the highest variance across the columns (samples) and
arrange the rows of subsetted matrix by decreasing variance.

Also modify `plot_pca()` and `plot_heatmap()` so they will accept the `n_top_features` parameter,
pass it to `select_var_features()` and do what should they do on the subsetted matrix `m`.

Then make a Rmd file named `n_top_features.Rmd` in which you will:

- Load the Rds file with `norm_data` object located in `E04-microarrays/norm_data.Rds`, and source `age_library.R`
  with implemented `select_var_features()` and other functions.
- Make a PCA plot and heatmap using `n_top_features = 1000` and colored (annotated) by `sample_group`.

Then render this Rmd file to `n_top_features.html`.

> In this exercise, there are several cases of `n_top_features` usage in PCA and heatmaps.

## Task 2

The second assignment will be to implement a "signpost" (`dea_signpost.Rmd`) and template (`dea_table_template.Rmd`) Rmd files,
and R script (`report.R`) for reporting of differential expression analysis results.

In the `report.R` script load the `fit` object located in `E04-microarrays/fit.Rds` and
for each of the contrasts render the `dea_table_template.Rmd` file to `<contrast_name>.html`
which will contain the contrast results table obtained from `topTable()`.
Filter the results such that $FDR < 0.1$ and $|LFC| > 1$.
Then render the `dea_signpost.Rmd` file to `dea_signpost.html` which will contain a table
with links to the rendered HTML files with contrast results.

A simplified procedure:

- `report.R`
  - Load the `fit` object.
  - Loop over the contrast results as `res`:
    - Render `dea_table_template.Rmd` with `res` table to `<contrast_name>.html`.
  - Render `dea_signpost.Rmd` to `dea_signpost.html` which will contain a table
    with contrast names and links to `<contrast_name>.html` files.

The implementation is very similar to the loop used in [*ReportingTools* section](#reportingtools),
but instead of using `ReportingTools` functions you will basically use `rmarkdown::render()`.
Detailed instructions are given in [*Custom reporting of DEGs* section](#custom-reporting-of-degs).

![Example of `dea_signpost.html`](`r here("E04-microarrays/_rmd_images/dea_signpost.png")`)

![Example of results table for one contrast (`groupacetaminophen.png`)](`r here("E04-microarrays/_rmd_images/groupacetaminophen.png")`)

***

Please, return the assignment in this form: 

- In the header of all Rmd files, put your name and e-mail to the `author` parameter.
- Copy the files to a directory named `E04-microarrays_assignment_<your_name>`:
  all files needed to reproduce your results (R and Rmd files), and rendered HTMLs.
  Put this directory to a ZIP archive named `E04-microarrays_assignment_<your_name>.zip`.
  - In the rendered HTMLs there should be included all code chunks with full output (warnings, messages, etc.).
- Upload the ZIP file to the appropriate assignment in MS Teams.

***

# Introduction

From [Wikipedia](https://en.wikipedia.org/wiki/DNA_microarray):

> A DNA microarray (also commonly known as DNA chip or biochip) is a collection of microscopic DNA spots attached to a solid surface.
  Scientists use DNA microarrays to measure the expression levels of large numbers of genes simultaneously or to genotype multiple regions of a genome.
  Each DNA spot contains picomoles (10âˆ’12 moles) of a specific DNA sequence, known as probes (or reporters or oligos).
  These can be a short section of a gene or other DNA element that are used to hybridize a cDNA or cRNA (also called anti-sense RNA)
  sample (called target) under high-stringency conditions. Probe-target hybridization is usually detected and quantified by
  detection of fluorophore-, silver-, or chemiluminescence-labeled targets to determine relative abundance of nucleic acid sequences in the target.

![A typical protocol for microarray experiment. mRNA is isolated from the sample and reverse transcribed to cDNA which
is labelled by fluorescent dye. The next steps are [hybridization](https://en.wikipedia.org/wiki/DNA_microarray#/media/File:NA_hybrid.svg),
in which cDNA hydridizes with probes on microarray, and the consequent washing, where non-specific sequences are removed, i.e. only strongly paired strands will remain hybridized.
The final wet-lab step is scanning in which the fluorescence intensity of probe spots is measured.
Total strength of the signal, from a spot (feature), depends upon the amount of target sample binding to the probes present on that spot.
Microarrays use relative quantitation in which the intensity of a feature is compared to the intensity of the same feature under
a different condition, and the identity of the feature is known by its position.
Intensities are summarised and analysis of data usually starts with normalization and technical quality control,
and is followed by exploratory analysis and testing for differential expression.
Image adapted from Wikipedia
([1](https://en.wikipedia.org/wiki/DNA_microarray#/media/File:Microarray_exp_horizontal.svg), 
[2](https://commons.wikimedia.org/wiki/File:Microarray_and_sequencing_flow_cell.svg)).](`r here("E04-microarrays/_rmd_images/microarray.png")`)

For a comphrehensive overview of Affymetrix microarrays data analysis check
[An end to end workflow for differential gene expression using Affymetrix microarrays](https://f1000research.com/articles/5-1384).

***

# Our experiment

Data come from [experiment](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE57822) where rats were separately treated with 127 compounds dissolved in corn oil.
To control rats only corn oil was given. The goal was to determine the carcinogenity of these compounds.
We will be working only with a subset, where are some well-known drugs:

- Acetaminophen
- Aspirin
- Diclofenac
- Ibuprofen

For each drug, we have 3 rats (= 3 biological replicates). For controls we have 6 rats.

The used chip is Affymetrix Rat Genome 230 2.0 Array (`Rat230_2`).

***

# Libraries

```{r, message = FALSE}
library(conflicted)
conflict_prefer("expand", "S4Vectors")
library(here)
library(emo)
library(tidyverse)
library(glue)
library(oligo)
library(limma)
conflict_prefer("plotMA", "limma")
library(ReportingTools)
library(lattice)
library(sva)

source(here("age_library.R"))
```

***

# Config

Input files:

```{r}
BASE_DIR <- here("E04-microarrays")
DATA_DIR <- here(BASE_DIR, "data")
EXPERIMENT_1_DATA_DIR <- here(DATA_DIR, "E-GEOD-57822")
EXPERIMENT_1_SAMPLE_SHEET_FILE <- here(EXPERIMENT_1_DATA_DIR, "E-GEOD-57822.sdrf.txt")

# This experiment will be used to demonstrate the batch effect.
EXPERIMENT_2_DATA_DIR <- here(DATA_DIR, "E-GEOD-68065")
EXPERIMENT_2_SAMPLE_SHEET_FILE <- here(EXPERIMENT_2_DATA_DIR, "E-GEOD-68065.sdrf.txt")
```

Parameters for differential expression analysis:

```{r}
REPORT_DIR <- here(BASE_DIR, "html_reports")
REPORT_N_GENES <- 50
REPORT_LFC_THRESHOLD <- 1
REPORT_P_VALUE_THRESHOLD <- 0.1
REPORT_P_VALUE_ADJUST_METHOD <- "fdr"
```

***

# Reading the data

## Phenotypical data

We need only few columns from the sample sheet. You can explore the `r str_replace(EXPERIMENT_1_SAMPLE_SHEET_FILE, fixed(".txt"), ".xlsx")` Excel sheet.

```{r}
pheno_data <- readr::read_delim(EXPERIMENT_1_SAMPLE_SHEET_FILE, delim = "\t", progress = FALSE) %>%
  dplyr::select(1, 48, 41) %>%
  magrittr::set_colnames(c("sample_name", "sample_group", "cel_file"))

pheno_data
```

Let's adjust the `pheno_data` a little bit more:

```{r}
pheno_data <- pheno_data %>%
  dplyr::mutate(
    sample_name = str_remove(sample_name, " 1"),
    sample_group = dplyr::if_else(sample_group == "not specified", "control", sample_group) %>%
      str_to_lower() %>%
      factor() %>%
      relevel("control")
  ) %>%
  as.data.frame() %>%
  magrittr::set_rownames(.$sample_name)

pheno_data
```

## CEL files

Microarray manufacturers use their own format to store intensity data, usually in binary form.
Affymetrix is using [CEL format](http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat545/Notes/AffxFileFormats/cel.html).

[oligo](https://www.bioconductor.org/packages/release/bioc/html/oligo.html) is a package for analyzing microarrays and supports Affymetrix
([user guide](https://www.bioconductor.org/packages/release/bioc/vignettes/oligo/inst/doc/oug.pdf)).
Raw data are stored in object of class `ExpressionFeatureSet`.

```{r}
cel_files <- glue("{EXPERIMENT_1_DATA_DIR}/{pheno_data$cel_file}")
raw_data <- read.celfiles(cel_files)
```

`raw_data` is object of class `ExpressionFeatureSet`, which is designated to store the raw (non-summarised, non-normalized) data from an experiment.
It is derived from `ExpressionSet` class, of which object we will obtain after data normalization.
`ExpressionSet` is one of the core Bioconductor's classes found in `Biobase` package.
It is used as a container for high-throughput assays and experimental metadata.
You can read its manual [here](https://www.bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf).

![The basic structure of `ExpressionSet` object.
There are three matrices:
<span class="assay">intensity (expression) matrix</span> (rows = probes, columns = samples),
<span class="pData">phenotypical (sample) data</span>, and
<span class="fData">feature (probe) data</span>, which adds additional information about probes (probe ID, gene ID, symbol, name, etc.).
The <span class="assay">expression matrix</span> is accesible via `exprs()`.
The <span class="pData">sample data</span> are accesible via `pData()` (or `phenoData()`, see below).
The <span class="fData">feature data</span> are accesible via `fData()` (or `featureData()`, see below).
It is important that the latter two matrices are linked to the
<span class="assay">expression matrix</span> via their rownames:
rownames of the <span class="pData">phenotypical matrix</span> match colnames of the
<span class="assay">expression matrix</span>, and rownames of the
<span class="fData">feature matrix</span> match rownames of the
<span class="assay">expression matrix</span>.
Anytime you subset any of the matrices, the rest will be automatically subsetted ("synchronization").
](`r here("E04-microarrays/_rmd_images/ExpressionSet.png")`)

There is also other data stored in `ExpressionSet`, such as `experimentData`, but that is not important for now.
You can find it in the manual above or see `?ExpressionSet`.
Alternatively, you can look at methods implemented by a class, in this case the `ExpressionSet`:

```{r}
methods(class = "ExpressionSet")
```

You can see all the stored data in the `raw_data` summary:

```{r}
raw_data
```

Rownames and colnames of `ExpressionSet` can be simply retrieved by the usual functions,
but for better readability is better to use the alternative `Biobase` functions:

```{r}
# or colnames(raw_data)
sampleNames(raw_data)

# or rownames(raw_data)
featureNames(raw_data) %>% head()
```

Rownames are now just row numbers, because we already haven't done the probe summarisation.

Sample and feature data are actually not a basic `data.frame`, but a more complex `AnnotatedDataFrame`.
That is a "special data frame" which consists of two parts:
dataframe describing metadata of samples and dataframe describing this metadata (i.e. its columns).

Let's create such an `AnnotatedDataFrame`.
First we change the sample names to a more neat form:

```{r}
sampleNames(raw_data) <- pheno_data$sample_name
```

Now we create metadata for `AnnotatedDataFrame`:

```{r}
metadata <- data.frame(
  labelName = colnames(pheno_data),
  labelDescription = c("", "Used drug.", "")
)

metadata
```

And finally the `AnnotatedDataFrame`:

```{r}
(pheno_data <- AnnotatedDataFrame(data = pheno_data, varMetadata = metadata))
```

We also combine `pheno_data` with existing pheno data, as there is some
existing information:

```{r}
phenoData(raw_data)
pData(raw_data) %>% head()
phenoData(raw_data) <- Biobase::combine(phenoData(raw_data), pheno_data)
phenoData(raw_data)
pData(raw_data) %>% head()
```

Look at the difference between `phenoData()` and `pData()`:
the former returns `AnnotatedDataFrame`, while the latter `data.frame`.

Accessing the metadata:

```{r}
varMetadata(raw_data)
```

Accessing the expression matrix:

```{r}
exprs(raw_data)[1:5, 1:5]
```

Subsetting works as for normal matrix, but will subset all matrices:

```{r}
raw_data_subset <- raw_data[1:5, 1:5]
raw_data_subset
exprs(raw_data_subset)
pData(raw_data_subset)
fData(raw_data_subset)
```

***

# Technical quality control

Now we will assess whether the experiment was performed correctly at the technical level.

_**Assumption: most of the genes do not change expression across the samples.**_

## Pseudo-image

Pseudo-image plots are used to assess the spatial distribution of the data on the chips.
Due to the magnitude of the readings, pseudo-images using data on the original scale often mask spatial features that may be present on the arrays.
This is why we recommend the use of the $log_2$ scale.

```{r}
image(raw_data, which = 12, transfo = log2)
```

You should see something like a random noise.
In the case of a larger area of the same color, there could be some technical problem.

## [MA plot](https://en.wikipedia.org/wiki/MA_plot)

$j, k$ ... arrays

$i$ ... probe

Difference in log-intensities of probe $i$: $M_i=log_2(Y_{i,j}/Y_{i,k})$

Average log-intensity of probe $i$: $A_i=\frac{1}{2}log_2(Y_{i,j}*Y_{i,k})$

Ideally, $M = 0$ should apply for all probes in all samples, due to the assumption that most of the genes do not change expression across the samples.

Here, we plot MA for each combination of three samples:

```{r}
MAplot(raw_data[, 12:14], pairs = TRUE)
```

We can also summarise sample groups. By default, median is used to summarise probe intensities across the samples.

```{r}
MAplot(raw_data, groups = pData(raw_data)$sample_group, pairs = TRUE)
```

## Boxplots

Ideally, we should see similar boxplots.

```{r}
boxplot(raw_data, nsample = nrow(raw_data))
```

## Probe level model

We will fit PLM using a robust regression which allows to calculate the standard errors of the coefficients.

$log_{2}(Y_{i,j})=\beta_j + \alpha_i + \epsilon_{i,j}$

$Y_{i,j}$ ... background corrected intensity of probe $i$ in sample $j$

$\beta_j$ ... true transcript intensity of sample $j$

$\alpha_i$ ... systematic bias of probe $i$

$\epsilon_{i,j}$ ... random noise of probe $i$ in sample $j$

```{r}
fit_plm <- fitProbeLevelModel(raw_data)
```

Let's see its properties:

```{r}
image(fit_plm, which = 12)
image(fit_plm, which = 12, type = "sign.residuals")
```

Again, as in the case of pseudo-image, you should see something like a random noise.
In the case of a larger area of the same color, there could be some technical problem.

## Relative log expression (RLE)

$y_{i,j}$ ... intensity of probe $i$ in sample $j$

For each probe $i$ we calculate its median intensity across the samples: $median(y_{i,*})$

Then we calculate deviations from this median: $y_{i,j} - median(y_{i,*})$

Ideally, RLE values should be spread around $0$.

```{r}
RLE(fit_plm)
```

## Normalized unscaled standard errors (NUSE)

We can look at the standard error estimates from PLM, for each probe on each array $j$.
They are standardized so that the median standard error across arrays is $1$ for each gene.

$NUSE(\beta_j)=\frac{SE(\beta_j)}{median_j(\beta_j)}$

Ideally, boxplots should be centered around $1$.
Samples having median above $1.1$ and/or higher spread can be considered as low quality ones ([source](http://arrayanalysis.org/main.html)).

```{r}
NUSE(fit_plm)
```

***

# Normalization and probe annotation

As we are working with Affymetrix microarrays, we use the RMA method for normalization:

```{r}
norm_data <- rma(raw_data)
```

Now we only know the probe IDs, but not the gene IDs they correspond to:

```{r}
featureNames(norm_data) %>% head()
```

And so we use a DB package [rat2302.db](http://bioconductor.org/packages/release/data/annotation/html/rat2302.db.html)
corresponding to our chip to annotate the probes.

All of those annotation packages use SQLite database as a backend and have a common interface called
[`AnnotationDbi`](https://bioconductor.org/packages/release/bioc/html/AnnotationDbi.html).

Some methods in `AnnotationDbi` have names similar to those from other packages (like `dplyr::select()`).
So always rather use the `AnnotationDbi::` prefix.

Note: because SQLite is a very simple database, it allows only one session (i.e. database file can be opened by only one user at the time).
So, by normal circumstances, it is not possible to use parallel processing when working with DB packages.

```{r}
library(rat2302.db)
rat2302.db
class(rat2302.db)
```

Let's show how to work with `AnnotationDbi` objects.

To show DB columns:

```{r}
AnnotationDbi::columns(rat2302.db)
```

We can show a description of each column:

```{r}
help("UNIGENE")
```

The primary keys of this DB are probe IDs:

```{r}
AnnotationDbi::keys(rat2302.db) %>% head()
```

But there are more key columns to use:

```{r}
AnnotationDbi::keytypes(rat2302.db)
```

And finally, we can select data using our list of keys. We also specify which columns we want to return and what is our keytype:

```{r}
feature_data <- AnnotationDbi::select(
  rat2302.db,
  # Which columns we want to retrieve from DB.
  columns = c("PROBEID", "ENSEMBL", "SYMBOL", "GENENAME", "ENTREZID"),
  # Vector of keys to use. Each key has a matching row in columns.
  keys = featureNames(norm_data),
  # Our key type is ID of probe.
  keytype = "PROBEID"
)

head(feature_data)
```

Some probes are targeting multiple genes:

```{r}
janitor::get_dupes(feature_data, PROBEID) %>% head()
```

How is it possible? Well, I am not sure `r emo::ji("slightly_smiling_face")` But one explanation could be that in the time microarray probes were designed,
they were really targeting a single gene, but some time later, a more precise genome annotation was released.

We have two options: to take the first gene, or to summarise gene information to single row.
In my opinion, the second option is better, as you won't lose any information.
On the other hand, you could have some problems, as, for example, ENSEMBL ID will look like this: `ENSRNOG00000013741, ENSRNOG00000042523`,
and that cannot be used, for example, in joining operations.

For the sake of completeness, we will try both options, but go further in the analysis with the first one.

Let's start with the second option, as we won't use it later.
We group `feature_data` by `PROBEID` and apply function to each of its other four columns.
This function joins values by `, `.

```{r}
feature_data_sum <- feature_data %>%
  dplyr::group_by(PROBEID) %>%
  dplyr::summarise(dplyr::across(c(ENSEMBL, SYMBOL, GENENAME, ENTREZID), ~ str_c(., collapse = ", ")))

head(feature_data_sum)
```

And now the first option. We simply drop duplicates with the `dplyr::distinct()` function.
We specify `PROBEID` column to be used for determining the uniqueness.

```{r}
feature_data <- dplyr::distinct(feature_data, PROBEID, .keep_all = TRUE)
```

Now we can filter `norm_data` and assign feature data to it:

```{r}
norm_data <- norm_data[feature_data$PROBEID, ]

if (any(feature_data$PROBEID != featureNames(norm_data)))
  stop("Feature data mismatch.")

fData(norm_data) <- feature_data
annotation(norm_data) <- "rat2302.db"
```

Feature data are also stored in `ExpressionSet` as `AnnotatedDataFrame`:

```{r}
featureData(norm_data)
```

But it is not needed to directly assign `AnnotatedDataFrame` - in the step above,
we have assigned just the dataframe with `fData(norm_data) <- feature_data`

Of note, some genes are targeted by multiple probes (if we take ENSEMBL ID as unique identifier):

```{r}
janitor::get_dupes(fData(norm_data), ENSEMBL) %>% head(10)
```

Depending on the situation, it is sometimes better to summarise such probes prior to downstream analyses.

However, rat genes are not so well annotated and many ENSEMBL IDs are NA:

```{r}
table(is.na(fData(norm_data)$ENSEMBL))
```

Prior to probe averaging, we have to drop probes with unknown ENSEMBL IDs.
Depending on the situation, this could be unwanted, as, in our case, we will lose about one third of probes.

```{r}
norm_data_avg <- norm_data
fdata_avg <- dplyr::filter(fData(norm_data), !is.na(ENSEMBL))
```

In qPCR we summarised technical replicates by the function `limma::avearrays()` -
a similar function operating on matrix rows is `limma::avereps()`:

```{r}
e_avg <- limma::avereps(exprs(norm_data)[fdata_avg$PROBEID, ], fdata_avg$ENSEMBL)
fdata_avg <- dplyr::distinct(fdata_avg, ENSEMBL, .keep_all = TRUE) %>%
  magrittr::set_rownames(.$ENSEMBL)
norm_data_avg <- ExpressionSet(e_avg, phenoData = phenoData(norm_data), featureData = AnnotatedDataFrame(fdata_avg))
norm_data_avg
```

Just for control, calculate means of one of the duplicated probes and compare it with the matching row in `norm_data_avg`:

```{r}
(x <- exprs(norm_data[c("1368344_at", "1370760_a_at"), ]))
(x <- colMeans(x))
(y <- exprs(norm_data_avg["ENSRNOG00000000007", ]))
stopifnot(all(x == y))
```

***

# Biological quality control

Now we are ready to look at some biology.
It is time to reuse your functions `r emo::ji("slightly_smiling_face")`

```{r}
groups <- pData(norm_data)$sample_group
names(groups) <- sampleNames(norm_data)
plot_hc(exprs(norm_data), color_by = groups, color_by_lab = "Sample Group")
plot_pca(exprs(norm_data), sample_data = pData(norm_data), n_top_features = 1000, color_by = "sample_group", plot_type = "multi")$plot
```

However, expression matrices tend to be quite noisy, e.g. a lot of features are not expressed at all or they are constant for all samples.
So better is to compute the PCA on a subset of top N most variable features (probes in our case):

```{r}
plot_pca(exprs(norm_data), sample_data = pData(norm_data), n_top_features = 1000, color_by = "sample_group", plot_type = "multi")$plot
```

For a heatmap, 1000 probes are enough. Don't use a big number of probes, or your browser will freeze `r emo::ji("wink")`

```{r}
plot_heatmap(
  exprs(norm_data)[1:1000, ],
  z_score = TRUE,
  column_annotation = dplyr::select(pData(norm_data), sample_group),
  title = "Affymetrix",
  legend_title = "z-score",
  show_row_names = FALSE
)
```

But again, a better way is to subset our expression matrix to contain only top N most variable probes:

```{r}
plot_heatmap(
  exprs(norm_data),
  n_top_features = 1000,
  z_score = TRUE,
  column_annotation = dplyr::select(pData(norm_data), sample_group),
  title = "Affymetrix",
  legend_title = "z-score",
  show_row_names = FALSE
)
```

***

# Differential expression analysis (DEA)

DEA tells us which genes are differentially expressed between conditions.
As in the qPCR, this is, again, a relative measure: for example, we can say that a gene is third times
more expressed in treatment group, relative to control group.

In the qPCR, we were using the simple t-test to test for the differential expression.
We could use that, because qPCR data are small enough to do so.
On the other hand, data from the high-throughput methods, such as microarrays and RNA-seq, are
much bigger and one of their properties is that the number of samples is always **much** smaller than the number of features.
For that reason, we have to do DEA using a more complex statistical method: linear models.

## `limma`

For DEA we will be using [limma](https://bioconductor.org/packages/release/bioc/html/limma.html).
It is the most known package (in top 20 packages in Bioconductor) for DEA of microarray data and was probably the first which has used linear models for that.

We will fit a linear model for each probe and improve estimates of standard errors using the empirical Bayes approach.
Because we have five sample groups (the first one being control), our model looks like this:

$Y_i = \beta_0 + \beta_1 x_{i,1} + \dotso + \beta_4 x_{i,4} + \epsilon_i, i = 1 \dotso N$

where $x$ are indicator variables and $i$ is a sample index. This can be rewritten to a matrix form as:

$$
  \begin{pmatrix}
    Y_1 \\ Y_2 \\
    \vdots \\
    Y_N\end{pmatrix} =
  \begin{pmatrix}
    1 & x_{1,1} & \dotso & x_{1,4} \\
    \vdots & \vdots & \ddots & \vdots \\
    1 & x_{N,1} & \dotso & x_{N,4}
  \end{pmatrix}
  \begin{pmatrix}
    \beta_0 \\
    \beta_1 \\
    \vdots \\
    \beta_4
  \end{pmatrix} +
  \begin{pmatrix}
    \epsilon_1 \\
    \epsilon_2 \\
    \vdots \\
    \epsilon_N
  \end{pmatrix}
$$

It can be simplified to:

$\mathbf{Y} = \mathbf{X \beta} + \mathbf{\epsilon}$

The matrix $\mathbf{X}$ is the design matrix. Let's make it:

```{r}
group <- pData(norm_data)$sample_group %>% factor() %>% relevel("control")
dea_model <- model.matrix(~ group)
colnames(dea_model)[1] <- "Intercept"
dea_model
```

So for example, how is the first sample of *diclofenac* group expressed?

$Y_{diclofenac,1} = \beta_0*1 + \beta_1*0 + \beta_2*0 + \beta_3*1 + \beta_4*0 + \epsilon = \beta_0 + \beta_3 + \epsilon$

Intercept is our $\beta_0$ (i.e. *control* = the reference group).
In a factor variable, the first level is automatically taken as the reference level.

Some models could be quite complicated. You can read more about model design [here](http://genomicsclass.github.io/book/) (Chapter 5).

Now we can fit the model and use the empirical Bayes shrinkage, which will basically improve parameter estimates
in our model by "borrowing" information from other probes:

```{r}
fit <- lmFit(norm_data, dea_model) %>% eBayes()
colnames(fit)
```

Using the `topTable()` function, we can look at differential expression statistics for each gene in a specific group
(in this case, *acetaminophen* vs *control*). We call these comparisons **contrasts** and genes meeting some statistical criteria
(FDR = significance, LFC = effect size) as **differentially expressed genes** (DEGs).

```{r}
topTable(fit, coef = "groupacetaminophen")
```

Let's inspect the `topTable` columns:

- `logFC`: $log_2(\text{fold-change})$ relative to a reference group (in this case `control`).
- `AveExpr`: average expression in a group (in this case `acetaminophen`).
- `t`: t-statistic.
- `P.Value`: p-value of the differential expression test.
- `adj.P.Val`: p-value adjusted for multiple testing issue.
- `B`: log-odds that the gene is differentially expressed.

We didn't specify any parameter to `topTable`, but if you look at its help page,
you can see that it is possible to set p-value adjust method and also thresholds for
adjusted p-value, as well as for minimal absolute value of LFC.
By default, it won't filter anything and return DEA statistics for first 10 genes by their `B` value.

## DEA between other sample groups

But what if we want to compare two non-control groups?
Well, we need to specify our own contrasts (in this case, *aspirin* vs *ibuprofen* and *acetaminophen* vs *diclofenac*):

```{r}
contrasts <- makeContrasts(
  aspirin_vs_ibuprofen = groupaspirin - groupibuprofen,
  acetaminophen_vs_diclofenac = groupacetaminophen - groupdiclofenac,
  levels = dea_model
)
contrasts
```

Behind it is just $(aspirin - control) - (ibuprofen - control) = aspirin - ibuprofen$, so comparison to control (reference) group simply cancels out.
Now we can refit our model using the defined contrasts:

```{r}
fit_c <- contrasts.fit(fit, contrasts = contrasts) %>% eBayes()
colnames(fit_c)
topTable(fit_c, coef = "aspirin_vs_ibuprofen")
```

## MA plot

The MA plot shows the mean of the expression intesity versus the LFCs for all genes tested.
The genes that are significantly DE are colored to be easily identified.
You can see that besides the technical quality control, MA plot is also usable to check for
to evaluate the magnitude of fold changes and how they are distributed relative to mean expression.
Generally, we would expect to see significantly DE genes across the full range of expression levels.

We use the [ggmaplot()](https://rpkgs.datanovia.com/ggpubr/reference/ggmaplot.html) function from `ggpubr` package,
which expects a dataframe with specifically named columns as the input (see `?ggmaplot()` for more details).
We also specify that genes with adjusted p-value (FDR) below 0.1 and fold-change of 2 (LFC = 1) will be treated as DE.

```{r}
res <- topTable(fit, coef = "groupacetaminophen", number = Inf) %>%
  dplyr::select(SYMBOL, baseMeanLog2 = AveExpr, log2FoldChange = logFC, padj = adj.P.Val)

ggpubr::ggmaplot(
  res,
  fdr = 0.1,
  fc = 2,
  genenames = res$SYMBOL,
  size = 1
)
```

## Volcano plot

Volcano plots are commonly used to display the results of RNA-seq or other omics experiments.
A volcano plot is a type of scatterplot that shows statistical significance (p-value) versus magnitude of change (LFC).
It enables quick visual identification of genes with large LFCs that are also statistically significant.
In a volcano plot, the most upregulated genes are towards the right, the most downregulated genes are towards the left,
and the most statistically significant genes are towards the top.

We will use [EnhancedVolcano](https://bioconductor.org/packages/release/bioc/html/EnhancedVolcano.html) package
which produces [highly customizable](https://bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html)
volcano plots in publication-ready quality.

```{r, fig.height = 8, fig.width = 8}
EnhancedVolcano::EnhancedVolcano(
  # A dataframe.
  toptable = res,
  # Vector of gene names.
  lab = res$SYMBOL,
  # Which column from toptable parameter to use for x and y values.
  x = "log2FoldChange",
  y = "padj",
  pCutoff = 0.1,
  # LFC cutoff (applied on x parameter).
  FCcutoff = 2,
  title = "Volcano plot",
  subtitle = "acetoaminophen vs. control",
  ylab = "-log10(adjusted p-value)",
  # To avoid overlapping gene labels, draw arrows for them.
  drawConnectors = TRUE
)
```

## `ReportingTools`

[ReportingTools](https://bioconductor.org/packages/release/bioc/html/ReportingTools.html) is a great package for HTML reporting of, but not only, DEA.
Basically, it outputs a table from the `topTable()`, but in an interactive HTML form.
It is working with many DE analysis packages, as you will see in RNA-seq.

We will iterate over all treatment sample groups and for each we create the HTML report.
Because `ReportingTools` are throwing error when no probe is meeting a filtering criteria,
we have to put the code inside the `tryCatch()` function.
The following code could be a bit complicated, so don't hesitate to ask me.

```{r, results = "asis"}
output_groups <- levels(groups)
output_groups <- output_groups[output_groups != "control"]

rep_theme <- reporting.theme()
lattice.options(default.theme = rep_theme)

for (group in output_groups) {
  tryCatch(
    {
      # This is an object (and a file) to which we are publishing.
      de_report <- HTMLReport(
        shortName = group,
        title = glue("{group} vs. control"),
        # reportDirectory = dirname(REPORT_DIR),
        basePath = REPORT_DIR
        # reportDirectory = REPORT_DIR
      )
      
      # We can control what to take from topTable.
      # Here, we want top REPORT_N_GENES DE genes (ranked by p-value adjusted by FDR) with minimal LFC of 1 (i.e. two-fold up or down).
      # We won't be much conservative and set adjusted p-value cutoff to 0.1. That means we expect 10 % of our DE genes to be false positives.
      publish(
        fit,
        de_report,
        eSet = norm_data,
        factor = groups,
        coef = glue("group{group}"),
        n = REPORT_N_GENES,
        lfc = REPORT_LFC_THRESHOLD,
        pvalueCutoff = REPORT_P_VALUE_THRESHOLD,
        adjust.method = REPORT_P_VALUE_ADJUST_METHOD
      )
      
      finish(de_report)
      
      cat(glue("\n\n<a href='{basename(REPORT_DIR)}/{group}.html' target='_blank'>Report of DEGs for <b>{group}</b> vs. control</a>", .trim = FALSE))
    },
    
    error = function(e) {
      cat(glue("\n\n<b>{group}</b> vs. control: {e$message}", .trim = FALSE))
  })
}
```

## Custom reporting of DEGs

Alternatively to `ReportingTools`, it is also possible to make a custom report template in the Rmd format. You just need to:

- Make a parametrized Rmd file (howto [here](https://bookdown.org/yihui/rmarkdown/parameterized-reports.html) and
  [here](https://bookdown.org/yihui/rmarkdown-cookbook/parameterized-reports.html)).
- Format the output of `topTable()`: join with `fData()`, add HTML links to [ensembl.org](http://www.ensembl.org) (for ENSEMBL IDs) or
  [GeneCards](https://www.genecards.org/) (for SYMBOLs), or any other suitable database.
- Send it as a parameter to the Rmd file and use e.g. `DT::datatable()` to output pretty tables.
- You can also use more parameters: report title (e.g. contrast name), thresholds for DEGs (LFC, FDR, ...), sample data, ...

By using the custom Rmd file you have a full control over the content, which is otherwise a bit more laborious with `ReportingTools`,
in which, besides using `topTable()` output, you can also call `publish()` with any HTML element or another R object (e.g. dataframe)
and the output will be appended to the `HTMLReport` object and appears in the final HTML file.

Lastly, all tables in R can be easily exported to tab-delimited formats (CSV, TSV) or
Excel ([openxlsx](https://ycphs.github.io/openxlsx/index.html) package).

***

# Boxplots

We can use our boxplot functions also for microarray data.
In case of `plot_boxplots()`, we need to convert our `ExpressionSet` to the long format.
And this is a big drawback, because such dataframe will be **huge**.
So don't convert a full dataset at once, unless you have a lot of RAM.

We convert to the long format only the subset of first 4 probes:

```{r}
data_long <- exprs(norm_data)[1:4, ] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("PROBEID") %>%
  tidyr::pivot_longer(-PROBEID, names_to = "sample_name", values_to = "E") %>%
  dplyr::left_join(fData(norm_data), by = "PROBEID") %>%
  dplyr::left_join(pData(norm_data), by = "sample_name")

head(data_long)
```

Now let's make boxplots:

```{r}
plot_boxplots(
  data_long,
  x = "sample_group",
  y = "E",
  facet_by = "SYMBOL",
  color_by = "sample_group",
  main = "Affymetrix",
  x_lab = "Sample_Group",
  y_lab = "log2(expression intensity)",
  do_t_test = FALSE
) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```

As for the qPCR data, it would be nice to see LFC between the treatment groups and the `control` group.
Again, this is doable by subtracting the mean expression intensity of the `control` group.

***

# Batch effect

Batch effects are technical sources of variation that have been added to the samples during handling or,
in our case, by different technical preparation of the experiments.
They have to be removed, otherwise they act as confounding elements which can be wrongly interpreted as biological variation.

However, there are two different ways of batch effect correction, aimed for different purposes:

1. Correcting the values in expression matrix. This is done prior to exploratory analysis (e.g. PCA, heatmaps) in order to
   visualize the underlying biological effect. **You shouldn't use the corrected values for DE analysis!**
2. For DEA, including the batch effect factors in a linear model. In short, most DE models work best on uncorrected data.

These two different ways are nicely summarised [here](https://www.biostars.org/p/266507/#280157) and more rigorously in
[Methods that remove batch effects while retaining group differences may lead to exaggerated confidence in downstream analyses (2016)](https://academic.oup.com/biostatistics/article/17/1/29/1744261).

To demonstrate the batch effect, we will join two experiments. The one we have been working with and the
[second one](https://www.ebi.ac.uk/arrayexpress/experiments/E-GEOD-68065/) in which rats were treated with acetaminophen,
and which used the same microarray technology as the former.

The preprocessing is quite similar to what we have already done.

```{r}
pheno_data_2 <- readr::read_delim(EXPERIMENT_2_SAMPLE_SHEET_FILE, delim = "\t") %>%
  dplyr::select(1, 4, 5, 38) %>%
  magrittr::set_colnames(c("sample_name", "sample_group", "rat_status", "cel_file"))

head(pheno_data_2)
```

```{r}
pheno_data_2 <- pheno_data_2 %>%
  dplyr::filter(rat_status == "susceptible") %>%
  dplyr::mutate(
    sample_name = str_replace(sample_name, " 1", ""),
    sample_group = dplyr::if_else(str_detect(sample_group, "predose"), "control", "acetaminophen"),
    batch = 2L,
    rat_status = NULL
  )

pheno_data_2
```

We modify the sample sheet from the first experiment to contain only *control* and *acetaminophen* samples and concatenate it rowwise with `pheno_data_2`:

```{r}
pheno_data_batch <- pData(norm_data) %>%
  dplyr::filter(sample_group %in% c("control", "acetaminophen")) %>%
  dplyr::mutate(batch = 1L) %>%
  dplyr::bind_rows(pheno_data_2) %>%
  dplyr::mutate(
    index = NULL,
    sample_group = factor(sample_group) %>% relevel("control"),
    batch = factor(batch),
    cel_file = dplyr::if_else(batch == 1, glue("{EXPERIMENT_1_DATA_DIR}/{cel_file}"), glue("{EXPERIMENT_2_DATA_DIR}/{cel_file}"))
  ) %>%
  as.data.frame() %>%
  magrittr::set_rownames(.$sample_name)

pheno_data_batch
```

```{r}
raw_data_batch <- read.celfiles(pheno_data_batch$cel_file)

sampleNames(raw_data_batch) <- pheno_data_batch$sample_name
metadata <- data.frame(
  labelName = colnames(pheno_data_batch),
  labelDescription = c(""),
  stringsAsFactors = FALSE
)
pheno_data_batch <- AnnotatedDataFrame(data = pheno_data_batch, varMetadata = metadata)
phenoData(raw_data_batch) <- Biobase::combine(phenoData(raw_data_batch), pheno_data_batch)
```

```{r}
MAplot(raw_data_batch, groups = pData(raw_data_batch)$sample_group, pairs = TRUE)

boxplot_colors <- dplyr::if_else(pData(raw_data_batch)$batch == 1, "red", "blue")
boxplot(raw_data_batch, nsample = nrow(raw_data_batch), col = boxplot_colors)
legend("topright", legend = c("1", "2"), title = "Batch", col = c("red", "blue"), pch = 20)
```

```{r}
fit_plm_batch <- fitProbeLevelModel(raw_data_batch)
RLE(fit_plm_batch)
NUSE(fit_plm_batch)
```

Hmm, it looks suspicious, doesn't it? `r emo::ji("thinking")` Samples from the second batch seem to have a systematically shifted probe intensity.

```{r}
norm_data_batch <- rma(raw_data_batch)
```

At the biological level, you can see that the samples are obviously divided according to batches.

```{r}
groups_batch <- pData(norm_data_batch)$sample_group
batches <- pData(norm_data_batch)$batch
names(groups_batch) <- sampleNames(norm_data_batch)
names(batches) <- sampleNames(norm_data_batch)

plot_hc(exprs(norm_data_batch), color_by = groups_batch, color_by_lab = "Sample Group")
plot_hc(exprs(norm_data_batch), color_by = batches, color_by_lab = "Batch")
plot_pca(exprs(norm_data_batch), sample_data = pData(norm_data_batch), n_top_features = 1000, color_by = "sample_group", shape_by = "batch")$plot
plot_heatmap(
  exprs(norm_data_batch),
  n_top_features = 1000,
  z_score = TRUE,
  column_annotation = dplyr::select(pData(norm_data_batch), sample_group, batch),
  title = "Affymetrix batch effect",
  legend_title = "z-score",
  show_row_names = FALSE
)
```

The batch effect is quite obvious from the plots above.

## Correcting expression values for batch effect

Let's correct the batch effect with the `ComBat()` function from `sva` package.
We will specify how are samples divided to batches and what is our experimental design.
Using this information, `ComBat()` will try to remove the batch effect while preserving the biological one.

```{r}
norm_data_batch_combat <- norm_data_batch
exprs(norm_data_batch_combat) <- ComBat(exprs(norm_data_batch_combat), batch = batches, mod = model.matrix(~ groups_batch))
```

Let's look again at the biological exploratory analysis. The batch effect seems to be corrected `r emo::ji("slightly_smiling_face")`

```{r}
plot_hc(exprs(norm_data_batch_combat), color_by = groups_batch, color_by_lab = "Sample Group")
plot_hc(exprs(norm_data_batch_combat), color_by = batches, color_by_lab = "Batch")
plot_pca(exprs(norm_data_batch_combat), sample_data = pData(norm_data_batch_combat), n_top_features = 1000, color_by = "sample_group", shape_by = "batch")$plot
plot_heatmap(
  exprs(norm_data_batch_combat),
  n_top_features = 1000,
  z_score = TRUE,
  column_annotation = dplyr::select(pData(norm_data_batch_combat), sample_group, batch),
  title = "Affymetrix batch effect corrected with ComBat",
  legend_title = "z-score",
  show_row_names = FALSE
)
```

It is not perfect, but it seems that samples are now correctly divided by sample group.

Alternatively, an another method could be used for batch effect correction:

```{r}
norm_data_batch_limma <- norm_data_batch
exprs(norm_data_batch_limma) <- limma::removeBatchEffect(exprs(norm_data_batch_limma), batch = batches, design = model.matrix(~ groups_batch))
```

The results are quite similar to `ComBat()`:

```{r}
plot_hc(exprs(norm_data_batch_limma), color_by = groups_batch, color_by_lab = "Sample Group")
plot_hc(exprs(norm_data_batch_limma), color_by = batches, color_by_lab = "Batch")
plot_pca(exprs(norm_data_batch_limma), sample_data = pData(norm_data_batch_limma), n_top_features = 1000, color_by = "sample_group", shape_by = "batch")$plot
plot_heatmap(
  exprs(norm_data_batch_limma),
  n_top_features = 1000,
  z_score = TRUE,
  column_annotation = dplyr::select(pData(norm_data_batch_limma), sample_group, batch),
  title = "Affymetrix batch effect corrected with limma",
  legend_title = "z-score",
  show_row_names = FALSE
)
```

## Taking batch effect into account in DEA

Now we take the batch effect into account in the linear model used for DEA,
adding it as an another factor (covariate):

```{r}
dea_model_batch <- model.matrix(~ groups_batch + batches)
colnames(dea_model_batch)[1] <- "Intercept"
dea_model_batch
fit_batch <- lmFit(norm_data_batch, dea_model_batch) %>% eBayes()
colnames(fit_batch)
```

We are assuming that effects of `groups_batch` and `batches` are additive,
and so we can ask e.g. whether is there difference between `ibuprofen` and `control` regardless the
batch, which is assumed to have the same effect for all sample groups.
In other words, the batch effect is now "eaten" by the `batches` covariate, and so we observe the correct statistics
for the main biological effect of used drug (the `groups_batch` covariate).

***

# Cleanup

All R objects can be saved in Rds format with `saveRDS()`, and loaded with `readRDS()`.
We save the `norm_data` and `fit` objects, because you will use them in the assignment:

```{r}
saveRDS(norm_data, file = here(BASE_DIR, "norm_data.Rds"))
saveRDS(fit, here(BASE_DIR, "fit.Rds"))
```

```{r, warning = TRUE, message = TRUE}
save(list = ls(all.names = TRUE), file = here(BASE_DIR, "microarrays.RData"), envir = environment())

warnings()
traceback()
sessioninfo::session_info()
```

***
***

# HTML rendering

This chunk is not evaluated (`eval = FALSE`). Otherwise you will probably end up in recursive hell `r emo::ji("exploding_head")`

```{r, eval = FALSE, message = FALSE, warning = FALSE}
library(conflicted)
library(knitr)
library(here)

if (!require(rmdformats)) {
  BiocManager::install("rmdformats")
}

# You can set global chunk options. Options set in individual chunks will override this.
opts_chunk$set(warning = FALSE, message = FALSE, eval = TRUE)
rmarkdown::render(
  here("E04-microarrays/microarrays.Rmd"),
  output_file = here("E04-microarrays/microarrays.html"),
  envir = new.env(),
  knit_root_dir = here()
)
```
